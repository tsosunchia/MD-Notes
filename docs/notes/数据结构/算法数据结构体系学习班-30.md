# •算法数据结构体系学习班

## •第30节

### •Morris遍历

一种遍历二叉树的方式，并且时间复杂度O(N)，**额外空间复杂度O(1)**

通过利用原树中大量空闲指针的方式，达到节省空间的目的。

注：普通的二叉树遍历，空间复杂度为O(h)，h为二叉树的高度。无论自建栈，还是系统调用栈，高度h是省不掉的。

### •Morris遍历细节

假设来到当前节点cur，开始时cur来到头节点位置

1）如果cur没有左孩子，cur向右移动(cur = cur.right)

2）如果cur有左孩子，找到左子树上最右的节点mostRight：

​	 a. 如果mostRight的右指针指向空，让其指向cur，然后cur向左移动(cur = cur.left)

​	 b. 如果mostRight的右指针指向cur（自己），让其指向null，然后cur向右移动(cur = cur.right)

3）cur为空时遍历停止

### •Morris遍历实质

**建立了一种机制，实质是在用我左树上的最右节点的右指针状态，来标记我到底是第一次来到cur节点，还是第二次来到。**如果左树上的最右节点指向空，说明是第一次来到cur节点，然后让左树上的最右节点指向自己，来标记已经来过一次cur了。然后继续遍历下一个节点，下一个节点同理。

<img src="../../images/image-20211018153204465.png" alt="image-20211018153204465" style="zoom:50%;" />

生成了一种 Morris 序 a b d b e a c f c g，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次。

morris遍历时间复杂度依然是O(N)

> Morris 非常聪明，他聪明在哪儿？我们来看递归方法，注意注释 1 2 3 对应的位置。
>
> 1. 你在递归方法里，你知不知道你是第一次来到自己？你知道，因为系统栈把所有中间信息给你保留，栈记录了信息，你当然知道自己是第一次。
>
> 2. 你去了左树，当你再一次回到左树之后，你知不知道你是第二次回到自己？你知道，你怎么知道的？系统栈给你保留所有的过程信息，你当然知道你是第二次回到自己。
>
> 3. 然后你去你的右树，当你再次回到自己，要退出之前，你还会回到自己一次，不然你退出不了，你怎么知道你是第三次回到自己的？递归栈帮你实现了所有中间信息的记录，所以你知道。
>
> 你开辟的空间支持你知道是第几次回到自己。所以你可以认为，Morris遍历在利用我任何一个节点左树上的最右节点的右指针，向递归行为致敬。

```java
public static void process(Node root) {
    if (root == null) {
        return;
    }
    // 1
    process(root.left);
    // 2
    process(root.right);
    // 3
}
```

### Morris 遍历有啥用？

你在一个内存吃紧的空间，例如你是一个嵌入式编程/系统编程的程序员，内存有限，你的代码是要做一个系统，所有人的代码都要在你的系统上来跑。越底层的代码，就要求越高效、越省空间。只是你做 web 应用，觉得内存便宜了，你不需要关注，不代表其他程序员不关注，甚至可能很重要。阿波罗只需要 128 kb 就登月了，就是把所有的空间用到极致的结果。

### •题目

给定一棵二叉树的头节点head

求以head为头的树中，最小深度是多少？

> 面试时，面试官可能不知道有morris遍历，你需要先怼一个普通解，比如二叉树的递归套路，说从左边拿到什么，从右边拿到什么。说明你很有料。然后再去扯别的。
>
> 你看到一道题目。你千万别闷头想，你要找到什么一种感觉，就是你想东西是一个絮絮叨叨的人，你脑子里零星冒出想法 a b c d时，正常人是你自己去辨别 a 能不能走通 ，哦不行，b 不行，c 不行，哦 d 可以，当你拿出一个成熟意见的时候，你才跟面试官聊，不建议这样，因为费时间，而且你容易紧张。推荐做法：你有想法 a 的时候，感觉像自言自语，你给他念出来，每个想法都念叨出来，面试官内心希望难住你，但是你念叨出来了，他会想提醒你，不然揣着明白装糊涂没劲。所以不管你工作中是什么性格，面试场上你要做一个职业的人。不管面试官怎么样，遇到了你就得忍。