# DP

不需要讲可变参数变为严格的表结构，所以只需要记忆化搜索就可以了。

递归（参数设计很重要）->傻缓存->动态规划

从上(递归的入口)至下的缓存叫记忆化搜索，从下(base case)至上的缓存表叫dp表

##### DP 模型大套路

- 从左往右的尝试模型（硬币组合问题，有限/无限硬币个数）
  - 对于有限硬币个数的题目来说，求一个格子，只要拿到它的依赖格子就可以了，是O(1)的。
  - 对于无限硬币个数的题目来说，求一个格子，要干一个for循环出来，终止条件为sum>target。
  - 你用傻缓存的方法，也就是我们说的极具启发性的记忆化搜索的方法，和我改成了严格表结构的方法，它整体肯定是比暴力搜索要好的多，记忆化搜索是没有分析谁先依赖、谁后依赖，你没算过，你就去算，你算过，你就直接从表里拿到，返回了，这就是记忆化搜索。而严格表结构的动态规划是，我严格的整理好依赖关系，从这张表的简单位置填到复杂位置，也就是说它比记忆化搜索进一步去梳理了依赖的关系，从简单位置，通过这个依赖关系，算出复杂位置，进而求出所有表的过程。
  - 记忆化搜索就是你没算过，你就去干递归，你算过了，直接在记忆表里拿值。表结构就是，我从简单到复杂，我严格规定好我先算哪个，后算哪个。
  - 他俩的时间复杂度呢？如果没有枚举行为，你这张表有多大，你的复杂度就是多少。记忆化搜索和严格表结构的时间复杂度同样的好。有枚举行为的话，需要先搞出严格表结构，然后继续优化。
- 范围尝试模型（玩家，纸牌游戏），明确知道L R 就是范围，而且左下半区没用，只要求对角线和右上半区就可以了。
- 样本对应模型（一个样本做行，一个样本做列，通常以结尾讨论可能性。两个参数就是下标，可以明确的知道参数的变化范围，即能确定dp数组的大小）
  - https://leetcode.com/problems/longest-common-subsequence/ 最长公共子序列
  - https://leetcode.com/problems/longest-palindromic-subsequence/
    - 方法1：样本对应模型。一个翻转串和它原串的最长公共子序列，就是最长回文子序列（注意子串和子序列的区别）
    - 方法2：范围尝试模型
- 业务限制模型（我们设计的递归可变参数，不能直观的确定变化范围，需要认为限制，把范围大小估出来，“限制不够，业务来凑”，假设最差情况，看他能冲到多大。如果实在改不出严格位置依赖了，咱就哈希表傻缓存。）

<img src="../../images/image-20210920160024936.png" alt="image-20210920160024936" style="zoom:33%;" />

> 左神语录。。
>
> 在众多数学大牛中，我最讨厌的就是高斯，为啥？因为高斯为了显示自己特别牛逼，他把一个证明的所有思考轨迹全擦的干干净净，就给你留最后的结论以及中间简单的推理步骤，这个东西它毁掉很多的精华，有人说他像一个林间的老狐狸一样，用狐狸尾巴擦掉自己思维的所有轨迹，给你看到的证明都是特别漂亮的样子。有啥用啊？是，你被认为是外星人留在地球的遗孤，厉害，我等凡人只能膜拜，有啥用啊？你留下那些结论，你把那些思维轨迹都写出来，不是更加激励后人吗？
> 所以，以后有一天，你变成高手了，希望你对新手好一点。

